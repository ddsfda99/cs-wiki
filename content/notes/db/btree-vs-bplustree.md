---
title: "数据库索引与优化：从 B+ 树到 LSM 树"
date: 2025-09-22
---
# 数据库索引与优化：从 B+ 树到 LSM 树
## 一、为什么需要索引？
在没有索引时，数据库执行查询需要逐行扫描数据表，复杂度为 O(n)。
有了索引，数据库可以快速定位到目标记录，复杂度降为 O(log n)，性能提升显著。
索引的代价：提升了查询效率（读快），但写入变慢，因为每次写都需要更新索引结构。
## 二、常见索引类型
1. 主键索引（聚簇索引，Clustered Index）
数据表的行在磁盘上，是按照主键的顺序存储的。
主键索引的叶子节点直接存储整行数据，因此查询主键非常高效。
一张表只能有一个主键索引，因为数据只能有一种物理顺序。 
2. 二级索引（非聚簇索引，Secondary Index）
二级索引的叶子节点不存放整行数据，而是存放主键值。
当你通过二级索引找到主键值后，还需要再去主键索引里取整行数据，这个过程叫回表（Back to Table）。
一张表可以有多个二级索引（例如对 username、email 建索引）。
3. 哈希索引（Hash Index）
基于哈希表实现，查找速度极快，平均复杂度 O(1)。
适合等值查询（=），例如 WHERE id = 100。
不支持范围查询（BETWEEN、>、<），因为哈希函数打乱了顺序。
常见于内存数据库（如 Redis 的哈希结构）。
4. B+ 树索引（B+ Tree Index）
关系型数据库中最常见的索引结构。
节点有序，叶子节点通过链表相连。
支持等值查询和范围查询，在磁盘 I/O 上表现稳定。
被 MySQL（InnoDB）、PostgreSQL 默认采用。
5. LSM 树索引（Log-Structured Merge Tree Index）
面向高写入场景的索引结构。
写入先进入内存（MemTable），再批量刷盘为有序的 SSTable 文件，避免频繁随机写。
借助 Compaction（压缩合并） 保持数据有序和高效查询。
广泛用于分布式 NoSQL 数据库：Cassandra、ScyllaDB、HBase、LevelDB、RocksDB。
## 三、B 树与 B+ 树
1. 什么是键？
在各种查找树里，键（Key）就是用来比较和排序的值。
在数据库索引中，键通常就是建索引的那一列的值，比如 id、username。
在复合索引中，键可以是多个字段的组合 (lastname, firstname)。
键的作用：决定数据在树中存放的位置；查询时用键进行比较，判断是往左走还是往右走。
2. 二叉搜索树 (BST)
每个节点最多有 2 个孩子。
节点只存一个键，且满足：左子树的键 < 当前节点的键，右子树的键 > 当前节点的键。
例子：
```
     20
    /  \
  10    30
```
这里的 `10、20、30` 都是键。
问题：如果插入顺序不当，树会退化成链表，树高过大，查找效率下降。
3. M 路查找树（M-Way Search Tree）
为了让树更矮胖，可以让每个节点存多个键：
一个节点可以保存最多 M−1 个键；
拥有最多 M 个孩子；
节点中的键有序，并把值域分割成 M 段。
例子（M=4）：
```
   [ 10 | 20 | 40 ]
   /     |     |    \
 (<10) (10~20) (20~40) (>40)
```
如果查找 25 → 落在 20 和 40 之间 → 走第 3 个子树；
如果查找 5 → 小于 10 → 走第 1 个子树。
问题：普通 M 路树没有自平衡机制，插入顺序不当依旧会导致树高过大。
4. B 树（B-Tree）
B 树是在 M 路查找树的基础上增加了自平衡规则：
除根外，每个节点至少有 ⌈M/2⌉ 个孩子，至多 M 个孩子；
根节点至少有 2 个孩子；
所有叶子节点必须在同一层；
数据可以存放在所有节点中。
特点：
* 节点能存很多键 → 树很矮，磁盘 I/O 次数少；
* 查找、插入、删除都在 O(log n) 时间内完成；
* 数据既可能在内节点，也可能在叶子节点。
5. B+ 树（B+ Tree）
B+ 树是 B 树的优化版，也是数据库索引的主流结构。
关键区别：
* 内部节点：只存键，不存数据。
* 叶子节点：存放所有数据（或指向行的指针）。
* 叶子节点之间：用链表连接，形成顺序访问路径。
优点：
* 树更矮：内部节点只存键，能容纳更多分支，树高降低。
* 查找路径稳定：所有查找都走到叶子，性能可预测。
* 范围查询高效：找到左边界后，顺着叶子链表就能做范围扫描。
* 顺序访问友好：磁盘顺序读和预读效果好。
6. B+ 树节点与文件物理偏移
（1）节点与页（Page）的关系
数据库的磁盘 I/O 单位是 页（Page），InnoDB 默认大小为 16KB。
B+ 树的设计刚好契合这一点：一个节点 = 一个页。
这样做的好处是：
一次磁盘 I/O 就能把一个节点完整加载进内存；
节点能容纳大量键和子指针，树的高度降低，从根到叶一般只需 2~3 次访问。
（2）指针的本质：页号
在 B+ 树节点中，子指针并不是内存地址，而是页号。
数据库会根据物理偏移 = 页号 × 页大小
计算出在文件中的位置，直接跳转读取该页。
（3）随机读
查询一条记录时，可能需要走过路径：根节点 → 内节点 → 叶子节点
每一级的页号都可能映射到文件的不同偏移位置，物理上并不连续。
这意味着磁盘必须一次次跳转到不同位置去读取数据，属于随机读。
（4）随机写
插入数据时，如果叶子页正好有空间，就直接写进去；
但如果页满了，就会触发分裂：系统分配一个新的页（可能在文件另一处），把一半数据搬过去，父节点更新或新增指针；如果父节点也满了，继续向上分裂，甚至根节点也可能分裂。
这就会导致在文件多个不同位置写入，属于随机写。
## 四、日志结构化存储（Log-structured Storage）
1. 随机写 vs 顺序写
机械硬盘（HDD）
随机写：每次写入都要让磁头移动到目标位置，再等盘片旋转到正确扇区，寻道 + 旋转延迟远大于真正的数据传输。
顺序写：磁头基本不动，磁盘可以持续写入。
差距：随机写可能比顺序写慢几十倍。

固态硬盘（SSD）
SSD 没有机械寻道，但闪存只能按页写、按块擦。
随机小写容易触发读-改-写，导致写放大和性能下降。
顺序写则能连续填充空闲页，减少擦除与合并操作。
差距：随机写比顺序写慢 3–10 倍。
2. 追加写（Append-only）
Log-structured Storage 的做法是：
不修改旧数据，而是直接把新数据追加到文件末尾。
文件末尾就是写指针，不断往后写。
好处：
写入始终是顺序写 → 吞吐高、延迟低；
崩溃恢复更简单 → 只要日志刷盘成功，就不会丢数据；
并发读简单 → 旧数据不变，新旧版本可以并存。
代价：
会产生历史版本和垃圾数据，需要后台清理。

## 四、SSTable
1. 什么是 KV？
在数据库里，最基本的数据模型就是 KV（Key-Value，键值对）：
* Key（键）：唯一标识数据的字段，例如用户 ID、订单号。
* Value（值）：与 Key 对应的内容，可以是字符串、数字、JSON，甚至二进制数据。
```
Key   = "user:1001"
Value = { "name": "Alice", "age": 25, "email": "alice@example.com" }
```
很多现代数据库（如 Redis、RocksDB、Cassandra）本质上就是 KV 存储系统。
2. 什么是 SSTable？
SSTable（Sorted String Table）是 LSM 树的核心存储单元，本质上是一个不可变的、有序的 KV 文件。
* 有序：所有 KV 按 Key 升序排列。
  * 支持二分查找，快速定位；
  * 支持高效范围查询；
  * 多个文件可用归并排序快速合并。
* 不可变：一旦写入磁盘就不再修改。
  * 新写入和更新会生成新的 SSTable；
  * 旧文件通过Compaction逐步合并清理。
* 文件级别独立：单个 SSTable 自带索引和元数据，可以独立完成查找。
3. SSTable 文件的逻辑结构
从大方向上，SSTable 可分为两部分：
* 数据存储区（Data Blocks）：保存实际的 KV 数据，块内有序，通常带压缩和校验。
* 数据管理区（Meta/Index/Footer）：保存索引和元信息，帮助快速定位 KV。
典型布局如下：
* Data Blocks：实际存储的 KV 记录。
* Meta Blocks：如 Bloom Filter（快速判断 key 是否可能存在）、表属性等。
* Meta Block Index：meta 信息的目录，用于快速定位。
* Index Block：每个 Data Block 的稀疏索引（记录最大 key → 数据块偏移）。
* Footer：文件尾部，记录 Index 和 Meta Index 的位置，以及校验信息。
4. 读操作如何进行？
查询一个 key 的流程：
（1）读 Footer，拿到 Index 和 Meta 的位置。
（2）查 Index Block，二分查找定位到目标 Data Block。
（3）查 Bloom Filter，若判定“不可能存在”，可直接跳过该文件。
（4）读目标 Data Block，在块内搜索 key → 返回对应的 value。
5. 写操作与不可变性
写入数据先进入 MemTable（内存有序表）。
当 MemTable 满了，就刷盘生成一个新的 SSTable 文件。
更新/删除并不会修改旧文件，而是写入新版本（update），写入删除标记（tombstone）。
后台 Compaction 周期性合并多个 SSTable，清理旧版本与删除标记。
6. 为什么要不可变？
不可变带来三个直接好处：
（1）顺序写：生成 SSTable 只需顺序追加 → 写入吞吐高。
（2）并发读安全：文件不会变，多个线程可以放心并发查询。
（3）简化恢复：崩溃恢复时，只需重放 WAL + 重新加载 SSTable，数据结构一致性有保证。
## 五、




